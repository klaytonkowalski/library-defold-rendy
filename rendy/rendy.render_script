--------------------------------------------------------------------------------
-- License
--------------------------------------------------------------------------------

-- Copyright (c) 2024 Klayton Kowalski

-- This software is provided 'as-is', without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from the use of this software.

-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it freely,
-- subject to the following restrictions:

-- 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software.
--    If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.

-- 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.

-- 3. This notice may not be removed or altered from any source distribution.

--------------------------------------------------------------------------------
-- Information
--------------------------------------------------------------------------------

-- GitHub: https://github.com/klaytonkowalski/library-defold-rendy

--------------------------------------------------------------------------------
-- Dependencies
--------------------------------------------------------------------------------

local rendy = require "rendy.rendy"

--------------------------------------------------------------------------------
-- Constants
--------------------------------------------------------------------------------

local message_set_view_projection = hash("set_view_projection")
local message_window_resized = hash("window_resized")

--------------------------------------------------------------------------------
-- Variables
--------------------------------------------------------------------------------

local predicate_tile = nil
local predicate_particle = nil
local predicate_gui = nil
local predicate_text = nil

local clear_buffers = nil

--------------------------------------------------------------------------------
-- Local Functions
--------------------------------------------------------------------------------

local function apply_resize_mode_center(camera)
	local window_width_ratio = rendy.window_width / rendy.window_height
	local window_height_ratio = rendy.window_height / rendy.window_width
	local resolution_width_ratio = camera.resolution_width / camera.resolution_height
	local resolution_height_ratio = camera.resolution_height / camera.resolution_width
	local margin_width = window_width_ratio - resolution_width_ratio > 0 and (window_width_ratio - resolution_width_ratio) * rendy.window_height * camera.viewport_width or 0
	local margin_height = window_height_ratio - resolution_height_ratio > 0 and (window_height_ratio - resolution_height_ratio) * rendy.window_width * camera.viewport_height or 0
	camera.viewport_px = rendy.window_width * camera.viewport_x + margin_width * 0.5
	camera.viewport_py = rendy.window_height * camera.viewport_y + margin_height * 0.5
	camera.viewport_pw = rendy.window_width * camera.viewport_width - margin_width
	camera.viewport_ph = rendy.window_height * camera.viewport_height - margin_height
	local left = -camera.resolution_width * 0.5 * camera.zoom
	local right = camera.resolution_width * 0.5 * camera.zoom
	local bottom = -camera.resolution_height * 0.5 * camera.zoom
	local top = camera.resolution_height * 0.5 * camera.zoom
	camera.projection_transform = vmath.matrix4_orthographic(left, right, bottom, top, camera.z_min, camera.z_max)
	camera.frustum = camera.projection_transform * camera.view_transform
end

local function apply_resize_mode_expand(camera)
	camera.viewport_px = rendy.window_width * camera.viewport_x
	camera.viewport_py = rendy.window_height * camera.viewport_y
	camera.viewport_pw = rendy.window_width * camera.viewport_width
	camera.viewport_ph = rendy.window_height * camera.viewport_height
	local left = -rendy.window_width * 0.5 * camera.zoom
	local right = rendy.window_width * 0.5 * camera.zoom
	local bottom = -rendy.window_height * 0.5 * camera.zoom
	local top = rendy.window_height * 0.5 * camera.zoom
	camera.projection_transform = vmath.matrix4_orthographic(left, right, bottom, top, camera.z_min, camera.z_max)
	camera.frustum = camera.projection_transform * camera.view_transform
end

local function apply_resize_mode_stretch(camera)
	camera.viewport_px = rendy.window_width * camera.viewport_x
	camera.viewport_py = rendy.window_height * camera.viewport_y
	camera.viewport_pw = rendy.window_width * camera.viewport_width
	camera.viewport_ph = rendy.window_height * camera.viewport_height
	local left = -camera.resolution_width * 0.5 * camera.zoom
	local right = camera.resolution_width * 0.5 * camera.zoom
	local bottom = -camera.resolution_height * 0.5 * camera.zoom
	local top = camera.resolution_height * 0.5 * camera.zoom
	camera.projection_transform = vmath.matrix4_orthographic(left, right, bottom, top, camera.z_min, camera.z_max)
	camera.frustum = camera.projection_transform * camera.view_transform
end

local function set_view_projection_callback(camera_url, view_transform)
	for _, camera in pairs(rendy.cameras) do
		if camera_url == camera.camera_url then
			camera.view_transform = view_transform
			if camera.resize_mode_center then
				apply_resize_mode_center(camera)
			elseif camera.resize_mode_expand then
				apply_resize_mode_expand(camera)
			elseif camera.resize_mode_stretch then
				apply_resize_mode_stretch(camera)
			end
		end
	end
end

local function window_resized_callback()
	rendy.window_width = render.get_window_width()
	rendy.window_height = render.get_window_height()
end

local function activate_camera(camera)
	render.set_viewport(camera.viewport_px, camera.viewport_py, camera.viewport_pw, camera.viewport_ph)
	render.set_view(camera.view_transform)
	render.set_projection(camera.projection_transform)
end

--------------------------------------------------------------------------------
-- Engine Functions
--------------------------------------------------------------------------------

function init(self)
	window_resized_callback()
	predicate_tile = render.predicate({ hash("tile") })
	predicate_particle = render.predicate({ hash("particle") })
	predicate_gui = render.predicate({ hash("gui") })
	predicate_text = render.predicate({ hash("text") })
	local clear_color_red = sys.get_config_number("render.clear_color_red", 0)
	local clear_color_green = sys.get_config_number("render.clear_color_green", 0)
	local clear_color_blue = sys.get_config_number("render.clear_color_blue", 0)
	local clear_color_alpha = sys.get_config_number("render.clear_color_alpha", 0)
	local clear_color = vmath.vector4(clear_color_red, clear_color_green, clear_color_blue, clear_color_alpha)
	clear_buffers =
	{
		[render.BUFFER_COLOR_BIT] = clear_color,
		[render.BUFFER_DEPTH_BIT] = 1
	}
end

function update(self, dt)
	render.set_depth_mask(true)
	render.clear(clear_buffers)
	for _, camera in pairs(rendy.cameras) do
		if camera.active then
			activate_camera(camera)
			render.enable_state(render.STATE_DEPTH_TEST)
			render.draw(predicate_tile, { frustum = camera.frustum })
			render.draw(predicate_particle, { frustum = camera.frustum })
			render.disable_state(render.STATE_DEPTH_TEST)
		end
	end
	render.set_depth_mask(false)
	-- render.draw_debug3d({ frustum = camera.frustum })
	-- render.draw(predicate_gui, { frustum = camera.frustum })
	-- render.draw(predicate_text, { frustum = camera.frustum })
end

function on_message(self, message_id, message, sender)
	if message_id == message_set_view_projection then
		set_view_projection_callback(sender, message.view)
	elseif message_id == message_window_resized then
		window_resized_callback()
	end
end